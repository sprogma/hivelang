@page "/chat"
@rendermode @(new InteractiveWebAssemblyRenderMode(prerender: false))
@using Microsoft.AspNetCore.SignalR.Client
@using app1.Shared.Types
@inject NavigationManager Navigation
@inject IJSRuntime JS
@implements IAsyncDisposable

<PageTitle>Chat</PageTitle>

<div class="form-group">
    <label>
        User:
        <input @bind="userInput" />
    </label>
</div>
<div class="form-group">
    <label>
        Message:
        <input @bind="messageInput" size="50" />
    </label>
</div>
<button @onclick="Connect" disabled="@(!IsConnected)">Connect</button>
<button @onclick="Query" disabled="@(!IsConnected)">Query</button>
<button @onclick="GetCode" disabled="@(!IsConnected)">GetCode</button>

<button @onclick="Click" disabled="@(!IsConnected)">Click</button>

<hr>

<ul id="messagesList">
    @foreach (var message in messages)
    {
        <li>@message</li>
    }
</ul>

@code {
    private HubConnection? hubConnection;
    private List<string> messages = [];
    private string? userInput;
    private string? messageInput;
    private CodeProgram? code;
    private VarType? i64Type;
    private VarType? byteType;

    private ulong hiveId = 0;
    public bool IsConnected => hubConnection?.State == HubConnectionState.Connected;

    protected override async Task OnInitializedAsync()
    {
        hubConnection = new HubConnectionBuilder()
            .WithUrl(Navigation.ToAbsoluteUri("/hivehub"))
            .Build();

        hubConnection.On<string, string>("ReceiveMessage", (user, message) =>
        {
            var encodedMsg = $"{user}: {message}";
            messages.Add(encodedMsg);
            InvokeAsync(StateHasChanged);
        });

        hubConnection.On("QueryHive", async () =>
        {
            var res = new QueryHiveResult(0, Random.Shared.NextDouble(), Random.Shared.NextDouble());
            messages.Add($"answered with {res}.");
            await hubConnection.InvokeAsync("GetQueryResults", res);
            _ = InvokeAsync(StateHasChanged);
        });

        await hubConnection.StartAsync();
    }

    public async ValueTask DisposeAsync()
    {
        if (hubConnection is not null)
        {
            await hubConnection.DisposeAsync();
        }
    }

    private async Task Connect()
    {
        if (!IsConnected || hubConnection is null)
        {
            await JS.InvokeVoidAsync("alert", "Error: hub connection failed.");
            return;
        }
        hiveId = await hubConnection.InvokeAsync<ulong>("GetMyId");
        await JS.InvokeVoidAsync("alert", $"Connected! this client get id {hiveId}");
    }

    private async Task GetCode()
    {
        if (!IsConnected || hubConnection is null)
        {
            await JS.InvokeVoidAsync("alert", "Error: hub connection failed.");
            return;
        }
        code = await hubConnection.InvokeAsync<CodeProgram>("GetCode");
        i64Type = code.Types.Values.First(x => x.Type == TypeType.SCALAR && x.Name == "i64" && x.Bases[0] == 8);
        byteType = code.Types.Values.First(x => x.Type == TypeType.SCALAR && x.Name == "byte" && x.Bases[0] == 1);
        messages.Add(string.Join("<br>", code.Types.Values.Select(x => ($"[type {x.Name}]"))));
        foreach (var msg in code.Workers)
        {
            messages.Add($"WORKER: {msg.Key}:" + string.Join("<br>", msg.Value.Code.Select(x => $"[{x.Type}] {string.Join("", x.Data)}")));
        }
    }

    private async Task Query()
    {
        if (!IsConnected || hubConnection is null)
        {
            await JS.InvokeVoidAsync("alert", "Error: hub connection failed.");
            return;
        }
        var results = await hubConnection.InvokeAsync<QueryHiveResult[]>("QueryHive");
        messages.Add(string.Join("<br>", results.Select(x => $"Hive {x.ClientId} [load {x.Payload}/{x.Potential}]")));
    }


    private async Task Click()
    {
        if (hubConnection is null)
        {
            await JS.InvokeVoidAsync("alert", "Connection failed!");
        }
        if (code is null)
        {
            await JS.InvokeVoidAsync("alert", "code is null!");
            return;
        }
        (RunningProgram? prg, ObjectBase[]? output) = await PrepareWorker(2,
                                                     [new ObjectScalar(code.Types.Values.First(x => x.Name == "i64"), [1, 0, 0, 0, 0, 0, 0, 0]),
                                                      new ObjectScalar(code.Types.Values.First(x => x.Name == "i64"), [10, 0, 0, 0, 0, 0, 0, 0])]);
        if (prg is not null && output is not null)
        {
            await RunWorker(prg);

            string results = string.Join(" ", output);
            await JS.InvokeVoidAsync("alert", $"As result, promise value now is {results}");
        }
    }

    private async Task<(RunningProgram?, ObjectBase[]? outputs)> PrepareWorker(long id, ObjectBase[] inputs)
    {
        if (code is null)
        {
            await JS.InvokeVoidAsync("alert", "Load code before running");
            return (null, null);
        }
        var program = new RunningProgram(code.Workers[id], inputs);
        var output = new List<ObjectBase>();
        foreach ((var varId, var type) in code.Workers[id].Outputs)
        {
            switch (type.Type)
            {
                case TypeType.PROMISE:
                    output.Add(program.Variables[varId] = new ObjectPromise(code.Types[type.Bases[0]]));
                    break;
                case TypeType.PIPE:
                    output.Add(program.Variables[varId] = new ObjectPipe(code.Types[type.Bases[0]]));
                    break;
                default:
                    throw new Exception("Error: output type isn't promise or pipe");
            }
        }
        return (program, output.ToArray());
    }

    private async Task<ResultCode> RunWorker(RunningProgram program)
    {
        if (i64Type is null || byteType is null)
        {
            await JS.InvokeVoidAsync("alert", "i64 or byte type is not found");
            return ResultCode.ERROR;
        }

        while (program.Ip < program.Worker.Code.Count)
        {
            Opcode opcode = program.Worker.Code[(int)program.Ip];

            // await JS.InvokeVoidAsync("alert", $"Operator {opcode.Type} [args {string.Join(" ", opcode.Data)}]");

            switch (opcode.Type)
            {
                case OpcodeType.LOAD_INPUT:
                    {
                        long varId = opcode.Data[0];
                        long inputId = opcode.Data[1];
                        program.Variables[varId] = program.Inputs[(int)inputId];
                        program.Ip++;
                    }
                    break;
                case OpcodeType.VARIABLE:
                    {
                        long tmpId = opcode.Data[0];
                        long varId = opcode.Data[1];
                        program.Temp[tmpId] = program.Variables[varId];
                        program.Ip++;
                    }
                    break;
                case OpcodeType.LOAD_INT:
                    {
                        long tmpId = opcode.Data[0];
                        long value = opcode.Data[1];
                        program.Temp[tmpId] = new ObjectScalar(i64Type, BitConverter.GetBytes(value));
                        program.Ip++;
                    }
                    break;
                case OpcodeType.LOAD_STRING:
                    {
                        long destId = opcode.Data[0];
                        long stringId = opcode.Data[1];
                        string str = program.Worker.Strings[stringId];
                        ObjectScalar[] data = System.Text.Encoding.UTF8.GetBytes(str).Select(x => new ObjectScalar(byteType, [x])).ToArray();
                        program.Temp[destId] = new ObjectArray(byteType, data);
                    }
                    break;
                case OpcodeType.LOAD_ARRAY:
                    {
                        long destId = opcode.Data[0];
                        long typeId = opcode.Data[1];
                        long sizeId = opcode.Data[2];
                        if (program.Temp[sizeId] is ObjectScalar os)
                        {
                            byte[] temp = new byte[8];
                            Buffer.BlockCopy(os.Value, 0, temp, 0, os.Value.Length);
                            long size = BitConverter.ToInt64(temp);
                            if (code.Types[typeId].Type == TypeType.SCALAR)
                            {
                                long itemSize = code.Types[typeId].Bases[0];
                                ObjectScalar[] data = Enumerable.Range(1, (int)size).Select(x => new ObjectScalar(code.Types[typeId], new byte[itemSize])).ToArray();
                                program.Temp[destId] = new ObjectArray(code.Types[typeId], data);
                            }
                            else
                            {
                                throw new NotImplementedException();
                                // program.Temp[destId] = new ObjectArray(code.Types[typeId], []);
                            }
                        }
                        program.Ip++;
                    }
                    break;
                case OpcodeType.PUSH_ARRAY_INDEX:
                    {
                        long destId = opcode.Data[0];
                        long indexId = opcode.Data[1];
                        long valueId = opcode.Data[2];
                        if (program.Temp[destId] is ObjectArray oa)
                        {
                            if (program.Temp[indexId] is ObjectScalar os)
                            {
                                byte[] temp = new byte[8];
                                Buffer.BlockCopy(os.Value, 0, temp, 0, os.Value.Length);
                                long index = BitConverter.ToInt64(temp);
                                oa.Items[index] = program.Temp[valueId];
                            }
                        }
                        program.Ip++;
                    }
                    break;
                case OpcodeType.ARRAY_INDEX:
                    {
                        long destId = opcode.Data[0];
                        long arrayId = opcode.Data[1];
                        long indexId = opcode.Data[2];
                        if (program.Temp[arrayId] is ObjectArray oa)
                        {
                            if (program.Temp[indexId] is ObjectScalar os)
                            {
                                byte[] temp = new byte[8];
                                Buffer.BlockCopy(os.Value, 0, temp, 0, os.Value.Length);
                                long index = BitConverter.ToInt64(temp);
                                program.Temp[destId] = oa.Items[index];
                            }
                        }
                        program.Ip++;
                    }
                    break;
                case OpcodeType.PUSH_VARIABLE:
                    {
                        long varId = opcode.Data[0];
                        long tempId = opcode.Data[1];
                        switch (program.Temp[tempId])
                        {
                            case ObjectScalar os:
                                program.Variables[varId] = program.Temp[tempId];
                                break;
                            case ObjectArray oa:
                                program.Variables[varId] = program.Temp[tempId];
                                break;
                            case ObjectPromise ops:
                                /* set it as signaling */
                                ops.Value = program.Temp[tempId];
                                break;
                            case ObjectPipe ope:
                                ope.Pipe.Enqueue(program.Temp[tempId]);
                                break;
                        }
                        program.Ip++;
                    }
                    break;
                case OpcodeType.ADD: await ArithmeticOpcode(program, opcode, (x, y) => x + y); break;
                case OpcodeType.SUB: await ArithmeticOpcode(program, opcode, (x, y) => x - y); break;
                case OpcodeType.MUL: await ArithmeticOpcode(program, opcode, (x, y) => x * y); break;
                case OpcodeType.DIV: await ArithmeticOpcode(program, opcode, (x, y) => x / y); break;
                case OpcodeType.MOD: await ArithmeticOpcode(program, opcode, (x, y) => x % y); break;
                case OpcodeType.BAND: await ArithmeticOpcode(program, opcode, (x, y) => x & y); break;
                case OpcodeType.BOR: await ArithmeticOpcode(program, opcode, (x, y) => x | y); break;
                case OpcodeType.BXOR: await ArithmeticOpcode(program, opcode, (x, y) => x ^ y); break;
                case OpcodeType.AND: await ArithmeticOpcode(program, opcode, (x, y) => (x != 0) && (y != 0) ? -1 : 0); break;
                case OpcodeType.OR: await ArithmeticOpcode(program, opcode, (x, y) => (x != 0) || (y != 0) ? -1 : 0); break;
                case OpcodeType.XOR: await ArithmeticOpcode(program, opcode, (x, y) => (x != 0) ^ (y != 0) ? -1 : 0); break;
                case OpcodeType.LT: await ArithmeticOpcode(program, opcode, (x, y) => x < y ? -1 : 0); break;
                case OpcodeType.LE: await ArithmeticOpcode(program, opcode, (x, y) => x <= y ? -1 : 0); break;
                case OpcodeType.GT: await ArithmeticOpcode(program, opcode, (x, y) => x > y ? -1 : 0); break;
                case OpcodeType.GE: await ArithmeticOpcode(program, opcode, (x, y) => x >= y ? -1 : 0); break;
                case OpcodeType.EQ: await ArithmeticOpcode(program, opcode, (x, y) => x == y ? -1 : 0); break;
                case OpcodeType.NE: await ArithmeticOpcode(program, opcode, (x, y) => x != y ? -1 : 0); break;
                case OpcodeType.NOT: await ArithmeticOpcode(program, opcode, (x) => x == 0 ? -1 : 0); break;
                case OpcodeType.BNOT: await ArithmeticOpcode(program, opcode, (x) => ~x); break;
                case OpcodeType.JMP:
                    {
                        long dest = opcode.Data[0];
                        program.Ip = dest;
                    }
                    break;
                case OpcodeType.JNZ:
                    {
                        long dest = opcode.Data[0];
                        long guard = opcode.Data[1];
                        if (program.Temp[guard] is ObjectScalar scalar && scalar.Value.Any(x => x != 0))
                        {
                            program.Ip = dest;
                        }
                        else
                        {
                            program.Ip++;
                        }
                    }
                    break;
                case OpcodeType.JZ:
                    {
                        long dest = opcode.Data[0];
                        long guard = opcode.Data[1];
                        if (program.Temp[guard] is ObjectScalar scalar && scalar.Value.All(x => x == 0))
                        {
                            program.Ip = dest;
                        }
                        else
                        {
                            program.Ip++;
                        }
                    }
                    break;
                case OpcodeType.QUERY:
                    {
                        long destId = opcode.Data[0];
                        long objectId = opcode.Data[1];
                        switch (program.Temp[objectId])
                        {
                            case ObjectArray oa:
                                program.Temp[destId] = new ObjectScalar(i64Type, BitConverter.GetBytes(oa.Items.LongLength));
                                break;
                            case ObjectPromise ops:
                                if (ops.Value is null)
                                {
                                    return ResultCode.HANG;
                                }
                                program.Temp[destId] = ops.Value;
                                break;
                            case ObjectPipe ope:
                                if (ope.Pipe.Count == 0)
                                {
                                    return ResultCode.HANG;
                                }
                                program.Temp[destId] = ope.Pipe.Dequeue();
                                break;
                            default:
                                throw new Exception("Error: QUERY of not array, promise or pipe");
                        }
                        program.Ip++;
                    }
                    break;
                default:
                    await JS.InvokeVoidAsync("alert", $"Unknown Opcode {opcode.Type}");
                    program.Ip++;
                    break;
            }

        }
        return ResultCode.OK;
    }

    private async Task ArithmeticOpcode(RunningProgram program, Opcode opcode, Func<long, long, long> operation)
    {
        long resId = opcode.Data[0];
        long aId = opcode.Data[1];
        long bId = opcode.Data[2];
        if (program.Temp[aId] is ObjectScalar a &&
            program.Temp[bId] is ObjectScalar b)
        {
            if (a.Value.Length == 8)
            {
                long result = operation(BitConverter.ToInt64(a.Value), BitConverter.ToInt64(b.Value, 0));
                program.Temp[resId] = new ObjectScalar(a.Type, BitConverter.GetBytes(result));
            }
            else if (a.Value.Length == 4)
            {
                int result = (int)operation(BitConverter.ToInt32(a.Value), BitConverter.ToInt32(b.Value, 0));
                program.Temp[resId] = new ObjectScalar(a.Type, BitConverter.GetBytes(result));
            }
            else if (a.Value.Length == 2)
            {
                short result = (short)operation(BitConverter.ToInt16(a.Value), BitConverter.ToInt16(b.Value, 0));
                program.Temp[resId] = new ObjectScalar(a.Type, BitConverter.GetBytes(result));
            }
            else if (a.Value.Length == 1)
            {
                byte result = (byte)operation(a.Value[0], b.Value[0]);
                program.Temp[resId] = new ObjectScalar(a.Type, [result]);
            }
        }
        else
        {
            await JS.InvokeVoidAsync("alert", $"Error! arithmeric operation with not number type");
        }
        program.Ip++;
    }

    private async Task ArithmeticOpcode(RunningProgram program, Opcode opcode, Func<long, long> operation)
    {
        long resId = opcode.Data[0];
        long aId = opcode.Data[1];
        if (program.Temp[aId] is ObjectScalar a)
        {
            if (a.Value.Length == 8)
            {
                long result = operation(BitConverter.ToInt64(a.Value));
                program.Temp[resId] = new ObjectScalar(a.Type, BitConverter.GetBytes(result));
            }
            else if (a.Value.Length == 4)
            {
                int result = (int)operation(BitConverter.ToInt32(a.Value));
                program.Temp[resId] = new ObjectScalar(a.Type, BitConverter.GetBytes(result));
            }
            else if (a.Value.Length == 2)
            {
                short result = (short)operation(BitConverter.ToInt16(a.Value));
                program.Temp[resId] = new ObjectScalar(a.Type, BitConverter.GetBytes(result));
            }
            else if (a.Value.Length == 1)
            {
                byte result = (byte)operation(a.Value[0]);
                program.Temp[resId] = new ObjectScalar(a.Type, [result]);
            }
        }
        else
        {
            await JS.InvokeVoidAsync("alert", $"Error! arithmeric operation with not number type");
        }
        program.Ip++;
    }
}